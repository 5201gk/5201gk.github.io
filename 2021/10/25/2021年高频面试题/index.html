<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/xxw/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.js的数据类型 基本数据类型：string number null  undefined boolean symbol  biglnt symbol  用来表示独一无二的数据 biglnt   可以安全储存和操作大整数  复杂数据类型  object  array   function   基本数据类型直接存放在栈中，复杂数据类型储存在堆内存中 2.如何判断数据类型 typeof  5   &#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="Gk的个人博客">
<meta property="og:url" content="http://example.com/2021/10/25/2021%E5%B9%B4%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/index.html">
<meta property="og:site_name" content="Gk的个人博客">
<meta property="og:description" content="1.js的数据类型 基本数据类型：string number null  undefined boolean symbol  biglnt symbol  用来表示独一无二的数据 biglnt   可以安全储存和操作大整数  复杂数据类型  object  array   function   基本数据类型直接存放在栈中，复杂数据类型储存在堆内存中 2.如何判断数据类型 typeof  5   &#x2F;">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-10-25T13:07:56.000Z">
<meta property="article:modified_time" content="2022-01-08T11:01:02.976Z">
<meta property="article:author" content="龚康">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2021/10/25/2021%E5%B9%B4%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | Gk的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Gk的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Code is my life</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/10/25/2021%E5%B9%B4%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://img2.baidu.com/it/u=1332361245,3416755263&fm=253&app=138&f=JPEG?w=500&h=500">
      <meta itemprop="name" content="龚康">
      <meta itemprop="description" content="Code is my life">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gk的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-10-25 21:07:56" itemprop="dateCreated datePublished" datetime="2021-10-25T21:07:56+08:00">2021-10-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-01-08 19:01:02" itemprop="dateModified" datetime="2022-01-08T19:01:02+08:00">2022-01-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h4 id="1-js的数据类型"><a href="#1-js的数据类型" class="headerlink" title="1.js的数据类型"></a>1.js的数据类型</h4><ol>
<li><p>基本数据类型：string number null  undefined boolean symbol  biglnt</p>
<p>symbol  用来表示独一无二的数据</p>
<p>biglnt   可以安全储存和操作大整数</p>
</li>
<li><p>复杂数据类型  object  array   function</p>
</li>
</ol>
<p>基本数据类型直接存放在栈中，复杂数据类型储存在堆内存中</p>
<h4 id="2-如何判断数据类型"><a href="#2-如何判断数据类型" class="headerlink" title="2.如何判断数据类型"></a>2.如何判断数据类型</h4><ol>
<li><p><strong>typeof</strong>  5   //number</p>
<p>typeof  null  // object</p>
</li>
<li><p><strong>instanceof</strong>   Array  //true </p>
</li>
<li><p>[5].<strong>_  <em>proto</em> _</strong> .constructor === Array // true</p>
<p>原理：通过 <strong>constructor</strong> 访问实例对象上的构造函数，不能用于判断 undefined , null</p>
</li>
<li><p>Object.prototype.toString.call(‘5’) // [object String] </p>
<p>原理：Object.prototype.toString方法返回对象的类型字符串，因此可用来判断一个值的类型。</p>
<p>因为实例对象有可能会自定义toString方法，会覆盖Object.prototype.toString，所以在使用时，最好加上call</p>
</li>
</ol>
<h4 id="3-js中的继承"><a href="#3-js中的继承" class="headerlink" title="3.js中的继承"></a>3.js中的继承</h4><ol>
<li>原型链继承，通过一个引用类型继承另一个引用类型的属性和方法</li>
<li>借用构造函数继承</li>
<li>组合继承，将原型链和构造函数的技术组合一起</li>
<li>型式继承，借助原型可以基于已有的对象创建新对象</li>
<li>寄生式继承</li>
<li>寄生组合式继承，通过借用函数来继承属性，通过原型链的混成形式继承方法</li>
<li>ES6 的继承：创造一个父类，子类通过 extends关键字，super指向父类的原型对象</li>
</ol>
<h4 id="4-原型链"><a href="#4-原型链" class="headerlink" title="4.原型链"></a>4.原型链</h4><p>当访问一个对象身上的属性时，会先从这个对象自身查找如果没有找到则会从它的 proto 隐式原型上查找，即它的构造函数的 prototype ，如果没有找到则会在构造函数的 prototype 的 proto 隐式原型上查找，这样一层一层向上查找会形成一个链式结构，成为原型链</p>
<h4 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5.闭包"></a>5.闭包</h4><p>一个作用域可以访问另一个函数内部的局部变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fun = fn()</span><br><span class="line">fun()</span><br></pre></td></tr></table></figure>

<h4 id="6-如何判断-this-的指向"><a href="#6-如何判断-this-的指向" class="headerlink" title="6.如何判断 this 的指向"></a>6.如何判断 this 的指向</h4><ol>
<li>以函数的形式调用时，this 指向window</li>
<li>以方法的形式调用时，this 指向调用者</li>
<li>以构造函数的形式调用时，this 指向新创建的对象</li>
<li>使用 call ，apply，bind 时，this 是携带的第一个参数</li>
<li>箭头函数的 this 如果外层有函数 this 指向外层函数的 this ，如果没有就是 window</li>
<li>通常意义上 this 指向最后调用它的对象，如果返回值是一个对象，那么 this 指向的就是返回的对象，如果不是 this 还是指向函数的实例</li>
</ol>
<h4 id="7-call，apply-，bind-的使用"><a href="#7-call，apply-，bind-的使用" class="headerlink" title="7. call，apply ，bind 的使用"></a>7. call，apply ，bind 的使用</h4><p>三者都可以通过携带的第一个参数 来改变函数内部的 this 指向，call 和 apply 可以调用函数，bind不可以。apply的第二个参数如果是多个则需要以数组的形式，call 则是以逗号隔开 </p>
<h4 id="8-数组常用的api"><a href="#8-数组常用的api" class="headerlink" title="8.数组常用的api"></a>8.数组常用的api</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">//forEach 遍历</span></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">item,index,arr</span>)=&gt;</span>&#123;<span class="built_in">console</span>.log(item,index)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//join 数组转字符串</span></span><br><span class="line">arr.join(<span class="string">&#x27;&#x27;</span>) <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//map 会返回一个新的数组不改变原数组，新数组中的值是处理后的值</span></span><br><span class="line">arr.map(<span class="function">(<span class="params">item,index,arr</span>)=&gt;</span>item+<span class="number">1</span>) <span class="comment">// [2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//push() 影响原数组，返回新数组的长度</span></span><br><span class="line">arr.push(<span class="number">4</span>) <span class="comment">// arr=[1,2,3,4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//pop() 删除数组最后一个元素，返回删除的元素</span></span><br><span class="line">arr.pop() <span class="comment">// arr=[1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//shift() 删除数组的第一个元素，返回删除的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//unshift() 在数组的前面添加元素，返回新数组的长度</span></span><br><span class="line">arr.unshift(<span class="number">0</span>) <span class="comment">// arr= [0,1,2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//reverse() 反向排序，会改变原数组，不会创建新的数组</span></span><br><span class="line">arr.reverse() <span class="comment">// arr = [3,2,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//sort() 对数组进行排序，如果没有参数则是按照字符编码的顺序进行排序</span></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a-b) <span class="comment">// [1,2,3]</span></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a,b</span>)=&gt;</span>b-a) <span class="comment">// [3,2,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//some() 检测数组中是否有满足条件的元素，如果有立即返回 true 不会检测剩余元素，否则返回 false ，</span></span><br><span class="line">arr.some(<span class="function"><span class="params">item</span>=&gt;</span>item===<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find() 返回第一个满足条件的元素 ，没有返回 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//every() 检测数组中的所有元素是否满足条件</span></span><br><span class="line">arr.every(<span class="function"><span class="params">item</span>=&gt;</span>item&gt;=<span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//filter() 将数组中所有满足条件的元素 以一个新数组的形式返回</span></span><br><span class="line">arr.filter(<span class="function"><span class="params">item</span>=&gt;</span>item&gt;=<span class="number">2</span>) <span class="comment">// [2,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//splice()  它既可以删除特定的元素，也可以在特定位置增加元素，也可以删除增加同时搞定，index是起始位置，hm是要删除元素的个数，add是要增加的元素</span></span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>) <span class="comment">// arr = [1,2,4,3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//conact() 用于连接两个或多个</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">arr.conact(arr2) <span class="comment">// [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>

<h4 id="9-reduce-的使用格式"><a href="#9-reduce-的使用格式" class="headerlink" title="9.reduce 的使用格式"></a>9.reduce 的使用格式</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">arr.reduce(<span class="function">(<span class="params">sum,item</span>)=&gt;</span>sum+item,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="10-什么是回调地域，如何解决"><a href="#10-什么是回调地域，如何解决" class="headerlink" title="10.什么是回调地域，如何解决"></a>10.什么是回调地域，如何解决</h4><p>当参数作为实参传给另外一个函数，并在函数外部调用，这样一层一层嵌套，层级结构过多，处理复杂这样就称为回调地狱。可以使用promise对象来解决</p>
<h4 id="11-promise的作用"><a href="#11-promise的作用" class="headerlink" title="11.promise的作用"></a>11.promise的作用</h4><p>Promise对象可以理解为一次执行的异步操作，使用promise对象之后可以使用一种链式调用的方式来组织代码；让代码更加的直观。避免了层层嵌套的回调函数，可以更清晰的表达，更加高效，更便于维护</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">&quot;拒绝了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;success&#x27;</span> + data);</span><br><span class="line">&#125;, <span class="function">(<span class="params">error</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">执行结果：<span class="string">&quot;拒绝了&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="12-new的背后做了哪些事情"><a href="#12-new的背后做了哪些事情" class="headerlink" title="12.new的背后做了哪些事情"></a>12.new的背后做了哪些事情</h4><ol>
<li>创建一个新的空对象</li>
<li>将空对象的 proto 指向构造函数的原型<ul>
<li>空对象的 proto 属性赋值为构造函数的 prototype 属性</li>
</ul>
</li>
<li>改变 this 指向，指向空对象</li>
<li>对构造函数的返回值做判断，然后返回对应的值</li>
</ol>
<h4 id="13-防抖和节流"><a href="#13-防抖和节流" class="headerlink" title="13.防抖和节流"></a>13.防抖和节流</h4><p>防抖：如果多次触发 只会执行最后一次</p>
<p>节流：一段时间内如果多次触发，只会执行第一次，等待执行完成后才能再次执行</p>
<h4 id="14-高阶函数"><a href="#14-高阶函数" class="headerlink" title="14.高阶函数"></a>14.高阶函数</h4><p>高阶函数就是 将函数作为实参传给另一个函数，或者返回值为函数的函数</p>
<h4 id="15-函数柯里化"><a href="#15-函数柯里化" class="headerlink" title="15.函数柯里化"></a>15.函数柯里化</h4><p>将可以接受多个参数的函数，转换成接受单个参数的函数</p>
<p>主要作用：参数复用、提前返回和延迟执行</p>
<h4 id="16-for-in-和-for-of-的区别"><a href="#16-for-in-和-for-of-的区别" class="headerlink" title="16.for in 和 for of 的区别"></a>16.for in 和 for of 的区别</h4><p><strong>for   in</strong>既可以遍历数组也可以遍历对象，遍历得到的值是 index 或  key</p>
<p><strong>for  of</strong>只能遍历数组，得到的是 数组中的每一个元素</p>
<h4 id="17-递归及应用场景"><a href="#17-递归及应用场景" class="headerlink" title="17.递归及应用场景"></a>17.递归及应用场景</h4><p>递归就是 函数内部调用自己</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="keyword">var</span> res = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  arr.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    item <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? fn(item) : res.push(item)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn(arr)</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="18-eventloop事件循环"><a href="#18-eventloop事件循环" class="headerlink" title="18.eventloop事件循环"></a>18.eventloop事件循环</h4><ol>
<li>执行初始化（script全局执行）代码, 将异步事件回调函数交给对应模块（线程）管理。</li>
<li>当事件被触发时, 管理模块（线程）会将回调函数及其数据添加到对应的回调列队中。</li>
<li>只有当初始化代码（script全局执行代码，也被称为宏任务）执行完后(可能要一定时间), 将任务队列中的微任务队列里的微任务依次执行（清空）；</li>
<li>当微任务队列中的所有微任务执行完成之后，再去取出任务队列中的下一个宏任务进行执行。</li>
</ol>
<h4 id="19-深拷贝和浅拷贝"><a href="#19-深拷贝和浅拷贝" class="headerlink" title="19.深拷贝和浅拷贝"></a>19.深拷贝和浅拷贝</h4><ul>
<li>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以<strong>如果其中一个对象改变了这个地址，就会影响到另一个对象</strong>。</li>
<li>深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且<strong>修改新对象不会影响原对象</strong>。</li>
</ul>
<h4 id="20-垃圾回收机制"><a href="#20-垃圾回收机制" class="headerlink" title="20.垃圾回收机制"></a>20.垃圾回收机制</h4><p>引用数据类型是保存在堆内存中，在栈中有一个对应的地址，操作引用数据类型实际操作的是对象的引用而不会操作实际的对象，当如果一个对象的地址指向了另一个对象，愿对象搁置，这样就产生了 垃圾，多了之后内存受不了，就会对没有用到的内存进行释放。</p>
<h4 id="21-await-async的使用方式"><a href="#21-await-async的使用方式" class="headerlink" title="21.await async的使用方式"></a>21.await async的使用方式</h4><ul>
<li>await只能在async函数中使用，不然会报错</li>
<li>async函数返回的是一个Promise对象，有无值看有无return值</li>
<li>await后面最好是接Promise，虽然接其他值也能达到排队效果</li>
<li>async/await作用是<strong>用同步方式，执行异步操作</strong></li>
</ul>
<h4 id="22-https和http的区别"><a href="#22-https和http的区别" class="headerlink" title="22.https和http的区别"></a>22.https和http的区别</h4><p><strong>Http</strong>是超文本传输协议，数据明文传输，所以会被抓包导致信息泄露，有安全风险问题！<strong>Https</strong> 则是具有安全性的SSL加密传输协议。<strong>Http</strong>和<strong>Https</strong>使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。<strong>Http</strong>的连接很简单,是无状态的。<strong>HTTPS</strong>协议是由<strong>SSL+HTTP</strong>协议构建的可进行加密传输、身份认证的网络协议。</p>
<h4 id="23-常见http的状态码"><a href="#23-常见http的状态码" class="headerlink" title="23.常见http的状态码"></a>23.常见http的状态码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span>   （成功）  服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 </span><br><span class="line"><span class="number">201</span>   （已创建）  请求成功并且服务器创建了新的资源。 </span><br><span class="line"><span class="number">202</span>   （已接受）  服务器已接受请求，但尚未处理。 </span><br><span class="line"><span class="number">203</span>   （非授权信息）  服务器已成功处理了请求，但返回的信息可能来自另一来源。 </span><br><span class="line"><span class="number">204</span>   （无内容）  服务器成功处理了请求，但没有返回任何内容。 </span><br><span class="line"><span class="number">205</span>   （重置内容） 服务器成功处理了请求，但没有返回任何内容。</span><br><span class="line"><span class="number">206</span>   （部分内容）  服务器成功处理了部分 GET 请求。</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">300</span>   （多种选择）  针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 </span><br><span class="line"><span class="number">301</span>   （永久移动）  请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。</span><br><span class="line"><span class="number">302</span>   （临时移动）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br><span class="line"><span class="number">303</span>   （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。</span><br><span class="line"><span class="number">304</span>   （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 </span><br><span class="line"><span class="number">305</span>   （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 </span><br><span class="line"><span class="number">307</span>   （临时重定向）  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">400</span>   （错误请求） 服务器不理解请求的语法。 </span><br><span class="line"><span class="number">401</span>   （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 </span><br><span class="line"><span class="number">403</span>   （禁止） 服务器拒绝请求。</span><br><span class="line"><span class="number">404</span>   （未找到） 服务器找不到请求的网页。</span><br><span class="line"><span class="number">405</span>   （方法禁用） 禁用请求中指定的方法。 </span><br><span class="line"><span class="number">406</span>   （不接受） 无法使用请求的内容特性响应请求的网页。 </span><br><span class="line"><span class="number">407</span>   （需要代理授权） 此状态代码与 <span class="number">401</span>（未授权）类似，但指定请求者应当授权使用代理。</span><br><span class="line"><span class="number">408</span>   （请求超时）  服务器等候请求时发生超时。 </span><br><span class="line"><span class="number">409</span>   （冲突）  服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 </span><br><span class="line"><span class="number">410</span>   （已删除）  如果请求的资源已永久删除，服务器就会返回此响应。 </span><br><span class="line"><span class="number">411</span>   （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 </span><br><span class="line"><span class="number">412</span>   （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。 </span><br><span class="line"><span class="number">413</span>   （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 </span><br><span class="line"><span class="number">414</span>   （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 </span><br><span class="line"><span class="number">415</span>   （不支持的媒体类型） 请求的格式不受请求页面的支持。 </span><br><span class="line"><span class="number">416</span>   （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 </span><br><span class="line"><span class="number">417</span>   （未满足期望值） 服务器未满足<span class="string">&quot;期望&quot;</span>请求标头字段的要求。</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">500   （服务器内部错误）  服务器遇到错误，无法完成请求。 </span><br><span class="line">501   （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 </span><br><span class="line">502   （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 </span><br><span class="line">503   （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 </span><br><span class="line">504   （网关超时）  服务器作为网关或代理，但是没有及时从上游服务器收到请求。 </span><br><span class="line">505   （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。</span><br></pre></td></tr></table></figure>

<h4 id="24-js延迟加载的方式"><a href="#24-js延迟加载的方式" class="headerlink" title="24.js延迟加载的方式"></a>24.js延迟加载的方式</h4><ol>
<li><p>defer 属性，在<script>标签上添加 defer 属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test1.js&quot;</span> <span class="attr">defer</span>=<span class="string">&quot;defer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>async 属性，在<script>标签上添加 async 属性</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;test1.js&quot;</span> <span class="attr">async</span> &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用 setTimeout 延迟方法</p>
</li>
<li><p>使用jquery 的 getScript() 方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.getScript(<span class="string">&quot;outer.js&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//回调函数，成功获取文件后执行的函数  </span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;脚本加载完成&quot;</span>)  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>把 js 外部引入的文件放到页面底部，来让js最后引入，从而加快页面加载速度</p>
</li>
</ol>
<h4 id="25-如何减少重绘和回流"><a href="#25-如何减少重绘和回流" class="headerlink" title="25.如何减少重绘和回流"></a>25.如何减少重绘和回流</h4><ol>
<li>减少对dom的操作</li>
<li>使用元素脱离文档流</li>
<li>避免访问或减少访问某些属性</li>
<li>避免对 css 进行单个修改</li>
</ol>
<h4 id="26-描述输入url地址到网页展示的过程"><a href="#26-描述输入url地址到网页展示的过程" class="headerlink" title="26.描述输入url地址到网页展示的过程"></a>26.描述输入url地址到网页展示的过程</h4><ol>
<li>通过 DNS 解析域名的实际IP地址</li>
<li>检查浏览器是否有缓存</li>
<li>与 WEB 服务器简历 TCP 连接</li>
<li>若协议是  HTTPS 则加密</li>
<li>浏览器发送请求获取页面 HTML</li>
<li>服务器响应 HTML</li>
<li>浏览器解析 HTML</li>
<li>浏览器渲染页面</li>
<li>浏览器发送请求</li>
<li>服务器响应 Ajax 求情</li>
<li>浏览器处理事件循环等异步逻辑</li>
</ol>
<h4 id="27-跨域问题及解决方案"><a href="#27-跨域问题及解决方案" class="headerlink" title="27.跨域问题及解决方案"></a>27.跨域问题及解决方案</h4><ol>
<li><p>跨域：受同源策略影响，限制一个 origin 的文档或者它加载的脚本与另一个源的资源进行交互。帮助阻隔恶意文档，减少可能被攻击</p>
</li>
<li><p>解决跨域：</p>
<ul>
<li><p>CORS：跨域资源共享（CORS）是一种机制，它使用额外的 HTTP 头来告诉浏览器，让运行在一个 origin 上的 web 应用被准许访问来自不同资源服务器上的指定资源。当一个资源与该资源本身所在的服务器 不同的域、协议或端口请求一个资源时，资源会发起一个 跨域 HTTP 请求</p>
</li>
<li><p>在 vue.config 中配置 proxy 方向代理 </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">proxy</span>:&#123;</span><br><span class="line">    <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">//  只要是url中有api的 就使用代理请求</span></span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;xxxx&#x27;</span> <span class="comment">// 我们要代理的真实接口地址</span></span><br><span class="line">        <span class="comment">// changeOrigin: true,</span></span><br><span class="line">        <span class="comment">// &#x27;^/api&#x27;: &#x27;/api&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>JSONP:主要利用了 script 标签没有跨域限制的这个特性来完成的（仅支持 GET 方法）</p>
</li>
</ul>
</li>
</ol>
<h4 id="28-本地持久化的方式和区别"><a href="#28-本地持久化的方式和区别" class="headerlink" title="28.本地持久化的方式和区别"></a>28.本地持久化的方式和区别</h4><ul>
<li>localStorage</li>
<li>sessionStorage</li>
<li>cookie</li>
</ul>
<p>区别：</p>
<ol>
<li><p>cookie 数据始终在同源的 http 请求中携带，localStorage，sessionStorage不会自动把数据发送给服务器，仅在本地保存。cookie 数据还有路径的概念，可以限制cookie 只属于某个路径下。</p>
</li>
<li><p>cookie 只能储存 4K 以内的数据，只适合储存小数据</p>
</li>
<li><p>session Storage 关闭浏览器 数据失效，而 localStorage 则始终有效，cookie 则是在有效期内有效</p>
</li>
<li><p>sessionStorage 只在同源窗口中共享 ，localStorage，cookie 所有窗口共享</p>
</li>
</ol>
<h4 id="29-get请求和post请求的区别"><a href="#29-get请求和post请求的区别" class="headerlink" title="29.get请求和post请求的区别"></a>29.get请求和post请求的区别</h4><ol>
<li>get 使用 url 或 cookie 穿参，post 将数据放在 body 中</li>
<li>get 的 url 长度有限制，post 的数据则可以非常大</li>
<li>get 传参显示在 url 中，post 更安全</li>
<li>get 一般涌来从服务器获取数据，post 用来想服务器提交数据</li>
</ol>
<h4 id="30-http的协议的三个内容"><a href="#30-http的协议的三个内容" class="headerlink" title="30.http的协议的三个内容"></a>30.http的协议的三个内容</h4><h4 id="31-请求头中的contentType有什么用处"><a href="#31-请求头中的contentType有什么用处" class="headerlink" title="31.请求头中的contentType有什么用处"></a>31.请求头中的contentType有什么用处</h4><p>设置请求头中的 Content-Type字段，告诉服务端你发送的数据是什么格式</p>
<h4 id="32-组件的生命周期钩子"><a href="#32-组件的生命周期钩子" class="headerlink" title="32.组件的生命周期钩子"></a>32.组件的生命周期钩子</h4><p>beforCreate，created，beforeMount，mounted，beforeUpdate，update，activated，deactivated，beforeDestroy，destroyed</p>
<h4 id="33-事件委托"><a href="#33-事件委托" class="headerlink" title="33.事件委托"></a>33.事件委托</h4><p>事件委托原理：不给每个字节点绑定时间，而是绑定在其父节点上，通过事件冒泡的原理委托给子节点</p>
<h4 id="34-事件冒泡和事件捕获"><a href="#34-事件冒泡和事件捕获" class="headerlink" title="34.事件冒泡和事件捕获"></a>34.事件冒泡和事件捕获</h4><ol>
<li>当点击某个元素的时候，事件执行从 window- document-body 往里一层一层 直到被点击的元素则为事件捕获。</li>
<li>事件冒泡 则是与捕获相反</li>
</ol>
<h4 id="35-哈希路由和history路由的区别"><a href="#35-哈希路由和history路由的区别" class="headerlink" title="35.哈希路由和history路由的区别"></a>35.哈希路由和history路由的区别</h4><p>hash 表示的是地址栏 URL 中#号，hash 会出现在 url 中，但是请求地址中不会出现，因此hash 值改变不会重新加载页面，当 # 后面的路径发生变化时，浏览器并不会重新发起请求。hash 传参是基于 url 的，如果需要传递复杂的参数会有体积限制。history 模式不仅可以在 URL 中传参，还可以将参数存放在一个特定的对象中。</p>
<h4 id="36-SPA"><a href="#36-SPA" class="headerlink" title="36.SPA"></a>36.SPA</h4><p>即单页面应用，就是只有一张 web 页面的应用。单页应用程序是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的 web 应用程序。浏览器一开始会加载必需的 HTML ，CSS ，Javascript ，所有的操作都在这张页面上完成，都由 JavaScript 来控制</p>
<h4 id="40-v-model和-sync的对比"><a href="#40-v-model和-sync的对比" class="headerlink" title="40.v-model和.sync的对比"></a>40.v-model和.sync的对比</h4><ol>
<li><p>v-model 传在 只能使用一次 ，.sync 可以使用多次</p>
</li>
<li><p>v-model 传参后，子组件 默认用 ‘value’ 接收，也可以通过以下方法修改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">model:&#123;</span><br><span class="line">  <span class="attr">prop</span>:<span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">  <span class="attr">event</span>:<span class="string">&#x27;updateMsg&#x27;</span> <span class="comment">// 有了这个事件 不需要父亲在通过传递函数来修改 </span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="attr">props</span>:[<span class="string">&#x27;message&#x27;</span>] <span class="comment">// 如果没有 model 中的 prop  则 是 prop:[&#x27;value&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>v-model 传参，子组件 通过调用父组件中的函数来更改，.sync 可以通过 update：来修改</p>
</li>
</ol>
<h4 id="41-vue路由钩子beforeEach的参数"><a href="#41-vue路由钩子beforeEach的参数" class="headerlink" title="41.vue路由钩子beforeEach的参数"></a>41.vue路由钩子beforeEach的参数</h4><p>router.beforeEach()  中的参数是一个函数，函数中有三个参数 to , from , next</p>
<h4 id="42-vuex使用的基本步骤"><a href="#42-vuex使用的基本步骤" class="headerlink" title="42.vuex使用的基本步骤"></a>42.vuex使用的基本步骤</h4><ol>
<li><p>新建一个 store/index.js 文件</p>
</li>
<li><p>下载 vuex 包并引入到 store 中 的 index.js ，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">msg</span>:<span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure></li>
<li><p>向 Vue 实例中注入 store </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.js</span></span><br><span class="line"><span class="comment">// 导入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// 省略其他...</span></span><br><span class="line">  store <span class="comment">// 2. 注入Vue实例</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>在组件中 使用 store 中的数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">       &lt;p&gt;</span><br><span class="line">			&#123;&#123;$store.state.msg&#125;&#125;==如果导入了mspState则直接==&#123;&#123;msg&#125;&#125;   	</span><br><span class="line">    	&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 1. 导入辅助函数mapState，它是在vuex中定义的一个工具函数。</span><br><span class="line">	  //  es6 按需导入 import &#123; mapState &#125; from &#x27;vuex&#x27; </span><br><span class="line">    import &#123;mapState&#125; from &quot;vuex&quot;</span><br><span class="line">    computed: &#123;</span><br><span class="line">   // 说明1： ...对象 是把对象展开，合并到computed</span><br><span class="line">   // 说明2： mapState是一个函数 </span><br><span class="line">   //  [&#x27;数据项1&#x27;， &#x27;数据项2&#x27;]</span><br><span class="line">   ...mapState([&#x27;msg&#x27;])</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>在组件中使用 store 中 mutations 里的函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    import &#123;mapMutations&#125; from &quot;vuex&quot;</span><br><span class="line">    methods: &#123;</span><br><span class="line">   // 说明1： ...对象 是把对象展开，合并到computed</span><br><span class="line">   // 说明2： mapState是一个函数 </span><br><span class="line">   //  [&#x27;数据项1&#x27;， &#x27;数据项2&#x27;]</span><br><span class="line">   ...mapMutations[&#x27;Fn&#x27;])</span><br><span class="line">   changeMsg()&#123;</span><br><span class="line">     this.Fn()</span><br><span class="line">    // 如果没有 导入 则是 this.$store.commit(&#x27;Fn&#x27;, 参数) </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="43-vue-中组件传值的方式"><a href="#43-vue-中组件传值的方式" class="headerlink" title="43.vue 中组件传值的方式"></a>43.vue 中组件传值的方式</h4><ul>
<li><p>子用 props 接受 ,用  $emit  调用父组件中的方法修改</p>
</li>
<li><p>$children , $parent</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 父组件中</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello_world&quot;&gt;</span><br><span class="line">    &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;</span><br><span class="line">    &lt;com-a&gt;&lt;/com-a&gt;</span><br><span class="line">    &lt;button @click=&quot;changeA&quot;&gt;点击改变子组件值&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import ComA from &#x27;./test/comA.vue&#x27;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;HelloWorld&#x27;,</span><br><span class="line">  components: &#123; ComA &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &#x27;Welcome&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeA() &#123;</span><br><span class="line">      // 获取到子组件A</span><br><span class="line">      this.$children[0].messageA = &#x27;this is new value&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 子组件中</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;com_a&quot;&gt;</span><br><span class="line">    &lt;span&gt;&#123;&#123;messageA&#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;p&gt;获取父组件的值为:  &#123;&#123;parentVal&#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      messageA: &#x27;this is old&#x27;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  computed:&#123;</span><br><span class="line">    parentVal()&#123;</span><br><span class="line">      return this.$parent.msg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>provide , inject ,父组件中通过<code>provide</code>来提供变量, 然后再子组件中通过<code>inject</code>来注入变量</p>
<blockquote>
<p>注意: 这里不论子组件嵌套有多深, 只要调用了<code>inject</code> 那么就可以注入<code>provide</code>中的数据，而不局限于只能从当前父组件的props属性中回去数据</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件中</span></span><br><span class="line"><span class="attr">provide</span>:&#123;</span><br><span class="line">	<span class="attr">msg</span>:<span class="string">&#x27;父亲中的值&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件中</span></span><br><span class="line"><span class="attr">inject</span>:[<span class="string">&#x27;msg&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li><p>ref  /   refs : 父组件中在子组件标签上添加 ref=‘xxx’ 属性，通过  this.$refs.xxx.’变量’ 来访问子组件中的变量 </p>
</li>
<li><p>eventBus </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// event-bus.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> EventBus = <span class="keyword">new</span> Vue()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在兄弟组件中用引入 </span></span><br><span class="line"><span class="keyword">import</span> &#123;EventBus&#125; <span class="keyword">from</span> <span class="string">&#x27;./event-bus.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 Event.$emit() 传值 ，Event.$on() 接受</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Vuex ：state，getters，mutations，actions，modules</p>
</li>
<li><p>$attrs :父组件直接在 子组件标签上写上需要穿的值 ，子组件中可以通过 <code>this.$attrs</code>获取到父组件传过来的值 ，自组件可以通过 v-bind=“$attr” 传给孙组件，$listeners 用法一样 用来传 方法/函数</p>
</li>
</ul>
<h4 id="47-computed-和-watche的使用区别"><a href="#47-computed-和-watche的使用区别" class="headerlink" title="47.computed 和 watche的使用区别"></a>47.computed 和 watche的使用区别</h4><ol>
<li><p>computed看上去是方法，但是实际上是计算属性，它会根据你所依赖的数据动态显示新的计算结果。计算结果会被缓存，computed的值在getter执行后是会缓存的，只有在它依赖的属性值改变之后，下一次获取computed的值时才会重新调用对应的getter来计算</p>
</li>
<li><p>watcher 更像是一个 data 的数据监听回调，当依赖的 data 的数据变化，执行回调，在方法中会传入 newVal 和 oldVal。</p>
</li>
</ol>
<h4 id="50-key的作用"><a href="#50-key的作用" class="headerlink" title="50.key的作用"></a>50.key的作用</h4><p>高效的更新虚拟 DOM ，其原理是 vue 在渲染过程中通过 <code>key</code> 可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少dom操作量，提高性能。</p>
<h4 id="51-vue2常用指令有哪些"><a href="#51-vue2常用指令有哪些" class="headerlink" title="51.vue2常用指令有哪些"></a>51.vue2常用指令有哪些</h4><p>v-model，v-bind, v-if  ,v-else ,  v-show , v-for , v-html， v-on ，</p>
<h4 id="52-vue2-和-vue3-的区别"><a href="#52-vue2-和-vue3-的区别" class="headerlink" title="52.vue2 和 vue3 的区别"></a>52.vue2 和 vue3 的区别</h4><ol>
<li>vue3 支持 vue2 的大多数特性，实现对 vue2 的兼容</li>
<li>vue3 对比 vue2 有明显的性能提升（打包体积减少，初次渲染加快，内存使用减少）</li>
<li>响应式原理不同</li>
<li>生命周期不同</li>
<li>在 Vue3 中，全局和内部 API 都经过了重构，并考虑到了 tree-shaking 的支持。因此，全局 API现在只能作为 ES 模块构建的命名导出进行访问。</li>
</ol>
<h4 id="53-vue2-中的过滤器是怎么使用的"><a href="#53-vue2-中的过滤器是怎么使用的" class="headerlink" title="53.vue2 中的过滤器是怎么使用的"></a>53.vue2 中的过滤器是怎么使用的</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用 Vue.filter() 方法在 main.js 注册 </span></span><br><span class="line">Vue.filter(<span class="string">&#x27;fn&#x27;</span>,<span class="function">()=&gt;</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.在组件中 局部注册</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">	<span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">	 <span class="attr">filters</span>:&#123;</span><br><span class="line">     <span class="function"><span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;  </span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.定义一个 filters.js</span></span><br><span class="line"><span class="keyword">let</span> fn=<span class="function">()=&gt;</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;fn&#125;</span><br><span class="line"><span class="comment">// 在组件中引入</span></span><br><span class="line"><span class="keyword">import</span> &#123;fn&#125; <span class="keyword">from</span> <span class="string">&#x27;./filters.js&#x27;</span></span><br></pre></td></tr></table></figure>



<h4 id="54-vue2中如何自定义指令"><a href="#54-vue2中如何自定义指令" class="headerlink" title="54.vue2中如何自定义指令"></a>54.vue2中如何自定义指令</h4><p><strong>全局注册：</strong>使用 <code>Vue.directive()</code>方法注册</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 main.js 中</span></span><br><span class="line">Vue.directive(<span class="string">&#x27;focus&#x27;</span>,&#123;</span><br><span class="line">    <span class="function"><span class="title">inserted</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">        el.foucs()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>局部注册：</strong>在 组件 <code>script</code> 标签中添加 <code>directives</code> 属性，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">      <span class="attr">focus</span>: &#123;</span><br><span class="line">          <span class="function"><span class="title">inserted</span>(<span class="params">el</span>)</span>&#123;</span><br><span class="line">              el.focus()</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="55-vue2-中的-vue-use-是怎么使用的"><a href="#55-vue2-中的-vue-use-是怎么使用的" class="headerlink" title="55.vue2 中的 vue.use 是怎么使用的"></a>55.vue2 中的 vue.use 是怎么使用的</h4><p><code>Vue.use()</code> 方法至少传入一个参数，该参数类型必须是 Object 或 Function，如果是 Object 那么这个 Object 需要定义一个 install 方法，如果是 Function 那么这个函数就被当做 install 方法。在 <code>Vue.use()</code> 执行时 install 会默认执行，当 install 执行时第一个参数就是 Vue，其他参数是 <code>Vue.use()</code> 执行时传入的其他参数。<code>Vue.use()</code> 是用来使用插件的，而这个插件本质上又是一个 install 方法。至于 install 方法内部实现了什么逻辑就由插件自身的业务决定了</p>
<h4 id="56-vue2中-nextTick"><a href="#56-vue2中-nextTick" class="headerlink" title="56.vue2中$nextTick"></a>56.vue2中$nextTick</h4><p>在下次<code>DOM</code>更新循环结束之后执行回调。在修改数据之后立即使用这个方法，获取更新之后的<code>DOM</code></p>
<h4 id="57-vue2-中响应式原理"><a href="#57-vue2-中响应式原理" class="headerlink" title="57.vue2 中响应式原理"></a>57.vue2 中响应式原理</h4><p>在 data 初始化时，将其属性转换成 <code>getter</code> 和 <code>setter</code>，同时实例化一个 <code>Dep</code>。视图渲染时， <code>getter</code> 触发，<code>Dep</code> 会收集 <code>Watcher</code>；在 <code>setter</code> 触发时，<code>Dep</code> 会通知其收集的 <code>Watcher</code> 更新视图。<code>Wathcer</code> 在组件挂载时实例化，<code>Watcher</code> 与组件一一对应。</p>
<h4 id="58-长轮询和短轮询"><a href="#58-长轮询和短轮询" class="headerlink" title="58.长轮询和短轮询"></a>58.长轮询和短轮询</h4><p>短轮询：浏览器每隔一段时间就发送请求，服务器立刻响应最新数据，如果没更新则是旧数据</p>
<p>长轮询：浏览器发送请求后，服务器不立刻响应，等待数据更新后才会响应，只有更新后才会响应</p>
<h4 id="59-虚拟-DOM"><a href="#59-虚拟-DOM" class="headerlink" title="59.虚拟 DOM"></a>59.虚拟 DOM</h4><p>使用 js 对象的方式，模拟真实的 dom 结构 ，属性的量大大减少，没有真实 dom 那么多无效的属性，对比起来性能高很多</p>
<h4 id="60-query-和-params-传递参数的区别"><a href="#60-query-和-params-传递参数的区别" class="headerlink" title="60.query  和 params 传递参数的区别"></a>60.query  和 params 传递参数的区别</h4><ol>
<li><p>params 传参，不许要用命名路由方式传参</p>
</li>
<li><p>params 传参，不会显示在地址栏中，刷新会丢失</p>
<p>接收： this.$route.query 和 this.$route.params</p>
</li>
</ol>
<h4 id="61-字符串的-API"><a href="#61-字符串的-API" class="headerlink" title="61.字符串的 API"></a>61.字符串的 API</h4><ol>
<li><p>截取字符串 <strong>substr() ，substring(), slice()</strong>, 接受的第一个参数都是截取的起始位置（包含起始位置），substr() 接受的第二个参数是 截取的长度，后两者的第二个参数是 结束为止（不包含结束位置）</p>
</li>
<li><p>replace(正则表达式/要被替换的字符，要替换成为的字符串) ,返回一个新的字符串</p>
</li>
<li><p>split()用于将一个字符串分割成字符串数组</p>
<p>![image-20220107102217833](/Users/gk/Library/Application Support/typora-user-images/image-20220107102217833.png)</p>
</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7010928535053271077">使用方法</a></p>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="龚康 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="龚康 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag"># 面试题</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/10/21/%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/01/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" rel="next" title="">
       <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-js%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.</span> <span class="nav-text">1.js的数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">2.如何判断数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-js%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">3.</span> <span class="nav-text">3.js中的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="nav-number">4.</span> <span class="nav-text">4.原型链</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E9%97%AD%E5%8C%85"><span class="nav-number">5.</span> <span class="nav-text">5.闭包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-this-%E7%9A%84%E6%8C%87%E5%90%91"><span class="nav-number">6.</span> <span class="nav-text">6.如何判断 this 的指向</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-call%EF%BC%8Capply-%EF%BC%8Cbind-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">7.</span> <span class="nav-text">7. call，apply ，bind 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84api"><span class="nav-number">8.</span> <span class="nav-text">8.数组常用的api</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-reduce-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A0%BC%E5%BC%8F"><span class="nav-number">9.</span> <span class="nav-text">9.reduce 的使用格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%9C%B0%E5%9F%9F%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">10.</span> <span class="nav-text">10.什么是回调地域，如何解决</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-promise%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">11.</span> <span class="nav-text">11.promise的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-new%E7%9A%84%E8%83%8C%E5%90%8E%E5%81%9A%E4%BA%86%E5%93%AA%E4%BA%9B%E4%BA%8B%E6%83%85"><span class="nav-number">12.</span> <span class="nav-text">12.new的背后做了哪些事情</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="nav-number">13.</span> <span class="nav-text">13.防抖和节流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="nav-number">14.</span> <span class="nav-text">14.高阶函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#15-%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="nav-number">15.</span> <span class="nav-text">15.函数柯里化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#16-for-in-%E5%92%8C-for-of-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">16.</span> <span class="nav-text">16.for in 和 for of 的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#17-%E9%80%92%E5%BD%92%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">17.</span> <span class="nav-text">17.递归及应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#18-eventloop%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="nav-number">18.</span> <span class="nav-text">18.eventloop事件循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#19-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">19.</span> <span class="nav-text">19.深拷贝和浅拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#20-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-number">20.</span> <span class="nav-text">20.垃圾回收机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#21-await-async%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">21.</span> <span class="nav-text">21.await async的使用方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#22-https%E5%92%8Chttp%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">22.</span> <span class="nav-text">22.https和http的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#23-%E5%B8%B8%E8%A7%81http%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81"><span class="nav-number">23.</span> <span class="nav-text">23.常见http的状态码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#24-js%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">24.</span> <span class="nav-text">24.js延迟加载的方式</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="龚康"
      src="https://img2.baidu.com/it/u=1332361245,3416755263&fm=253&app=138&f=JPEG?w=500&h=500">
  <p class="site-author-name" itemprop="name">龚康</p>
  <div class="site-description" itemprop="description">Code is my life</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">龚康</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/xxw/anime.min.js"></script>
  <script src="/xxw/velocity/velocity.min.js"></script>
  <script src="/xxw/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
